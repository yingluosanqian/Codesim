//现有 n 个数排成一行，如果两个相邻的数 u 和 v 的平均数为整数，则认为它们是 “ 上镜 ” 的。

//如何将这些数重新排列，使得 “ 上镜 ” 数对的数量最大？

//输入格式

//第一行包含一个整数 t（1≤t≤500）,即测试用例数。

//每个测试用例的第一行包含一个整数 n （2≤n≤2000）表示有 n 个数。

//每个测试用例的第二行包含 n 个整数 ， 每个整数不超过 2\cdot10^52?10 
//5
//输出格式
//对于每个测试用例，在一行输出 n 个整数，表示调整后的数列。如果有多个情况，则输出其中任何一个。
#include<bits/stdc++.h>
using namespace std;
int main(){
int f,m,t,n,a[501][2001],b[501][2001],c[501][2001];
f=m=0;
cin>>t;
for(int i=0;i<t;i++){
cin>>n;
for(int j=0;j<n;j++){
cin>>a[i][j];}
if(a[i][j]%2==0)
b[i][m++]=a[i][j];
else
c[i][f+]-=a[i][j];

}

for(int i-0;i<t;i++){

for(int j=0;i<f;j++){

cout<c[i][j]<" ";
}
for(int r=0;r<m;r++){

cout<<b[i][r]<<" ";
}
}
cout endl;
}



